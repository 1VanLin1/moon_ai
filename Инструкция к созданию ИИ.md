# Moon AI
## Что нужно для создания торгового ИИ?
### 1. Языки программирования
#### Основные варианты:
#### Python - наиболее популярный выбор:
* Богатые библиотеки для анализа данных (pandas, numpy, scikit-learn)
* Готовые библиотеки для работы с биржами (ccxt, pybit для ByBit)
* Отличные фреймворки для ML (TensorFlow, PyTorch)
* Простота разработки и тестирования
#### Другие варианты:
* C++ - для высокочастотной торговли (минимальные задержки)
* Java/C# - для enterprise-решений
* R - для сложного статистического анализа
#### Рекомендация: Начинайте с Python - это идеальный баланс между простотой и мощностью.
### 2. Ключевые компоненты системы
```python
# Примерная архитектура
class TradingAI:
    def __init__(self):
        self.data_processor = DataProcessor()  # обработка данных
        self.ml_model = MLModel()             # модель ИИ
        self.risk_manager = RiskManager()     # управление рисками
        self.api_client = ByBitAPI()          # подключение к бирже
```
### 3. Данные для обучения ИИ
####  Обязательные данные:
* Исторические цены (OHLCV - Open, High, Low, Close, Volume)
* Стакан цен (order book) с глубиной
* Торговые сделки (trades history)
* Технические индикаторы (RSI, MACD, Bollinger Bands, etc.)
#### Дополнительные данные:
*  Рыночные индикаторы (страх, жадность, волатильность)
*  Новостной фон (обработка текстовых новостей)
*  Данные с других бирж (арбитражные возможности)
*  Макроэкономические показатели
### 4. Подходы к созданию ИИ
#### a) Классические ML-модели:
*  Random Forest, Gradient Boosting (XGBoost, LightGBM)
*  SVM, нейронные сети
*  Обучение с учителем (предсказание направления цены)
#### b) Глубокое обучение:
* LSTM сети для временных рядов
* CNN для анализа стакана цен
* Reinforcement Learning (обучение с подкреплением)
#### c) Ансамбли моделей:
* Комбинация нескольких подходов
* Разные модели для разных рыночных режимов
###  5. Практическая реализация
``` python
# Пример подключения к ByBit API
from pybit import HTTP, WebSocket

# REST API для торговли
session = HTTP(
    endpoint="https://api.bybit.com",
    api_key="your_key",
    api_secret="your_secret"
)

# WebSocket для реальных данных
ws = WebSocket(
    channel_type="linear",
    symbol="BTCUSDT",
    api_key="your_key",
    api_secret="your_secret"
)
```
### 6. Критически важные аспекты
#### Управление рисками:
* Размер позиции (не более 1-2% от депозита на сделку)
* Stop-loss и Take-profit
* Максимальная просадка
* Волатильность инструмента
#### Бэктестинг:
```python
# Обязательно тестируйте на исторических данных!
def backtest_strategy(data, model):
    capital = 10000
    position = 0
    
    for i in range(len(data)):
        prediction = model.predict(data[i])
        if prediction > threshold and position == 0:
            # открываем long
            position = capital / data[i]['close']
        elif prediction < -threshold and position > 0:
            # закрываем long
            capital = position * data[i]['close']
            position = 0
    
    return capital
```
### 7. Пошаговый план разработки
1. Изучите API ByBit - документация доступна на сайте
2. Соберите исторические данные (можно через API или готовые датасеты)
3. Создайте простую стратегию (например, на основе скользящих средних)
4. Реализуйте бэктестинг и оптимизацию параметров
5. Добавьте ML-модель для предсказания цен
6. Внедрите управление рисками
7. Протестируйте на демо-счете
8. Запустите на реальные небольшие суммы
### 8. Риски и предупреждения
* Торговля криптовалютами крайне рискованна
* Даже лучшие ИИ могут нести убытки
* Всегда тестируйте на демо-счете перед реальной торговлей
* Начинайте с очень маленьких сумм
* Регулярно мониторьте и обновляйте модели
### 9. Полезные ресурсы
* Библиотеки: pandas, numpy, scikit-learn, TensorFlow/PyTorch, ccxt, pybit
* Данные: ByBit API, TradingView, Kaiko, Cryptodatadownload
* Образовательные ресурсы: QuantConnect, Udemy курсы по алгоритмической торговле
### Архитектура Trading AI для ByBit
```
trading-ai-bybit/
│
├── config/
│   ├── config.yaml              # Основные настройки
│   ├── api_keys.yaml           # Ключи API (в gitignore)
│   └── strategy_params.yaml    # Параметры стратегий
│
├── src/
│   ├── main.py                 # Точка входа
│   ├── core/                   # Ядро системы
│   │   ├── __init__.py
│   │   ├── trading_engine.py   # Движок торговли
│   │   ├── risk_manager.py     # Управление рисками
│   │   └── position_tracker.py # Отслеживание позиций
│   │
│   ├── data/                   # Работа с данными
│   │   ├── __init__.py
│   │   ├── data_collector.py   # Сбор данных
│   │   ├── data_processor.py   # Обработка и feature engineering
│   │   ├── market_data.py      # Реальные рыночные данные
│   │   └── historical_data.py  # Исторические данные
│   │
│   ├── ml/                     # ML компоненты
│   │   ├── __init__.py
│   │   ├── model_manager.py    # Управление моделями
│   │   ├── feature_engineer.py # Создание фичей
│   │   ├── models/             # Реализации моделей
│   │   │   ├── lstm_model.py
│   │   │   ├── xgboost_model.py
│   │   │   └── ensemble_model.py
│   │   └── training/           # Обучение моделей
│   │       ├── trainer.py
│   │       └── hyperparameter_tuning.py
│   │
│   ├── strategies/             # Торговые стратегии
│   │   ├── __init__.py
│   │   ├── base_strategy.py    # Базовый класс стратегии
│   │   ├── ml_strategy.py      # ML-стратегия
│   │   ├── mean_reversion.py   # Пример конкретной стратегии
│   │   └── trend_following.py  # Еще одна стратегия
│   │
│   ├── execution/              # Исполнение ордеров
│   │   ├── __init__.py
│   │   ├── bybit_client.py     # Клиент ByBit API
│   │   ├── order_manager.py    # Управление ордерами
│   │   └── websocket_handler.py # WebSocket для реальных данных
│   │
│   ├── backtesting/            # Бэктестинг
│   │   ├── __init__.py
│   │   ├── backtest_engine.py  # Движок бэктестинга
│   │   ├── performance.py      # Анализ результатов
│   │   └── metrics.py          # Метрики эффективности
│   │
│   └── utils/                  # Вспомогательные функции
│       ├── __init__.py
│       ├── logger.py           # Логирование
│       ├── helpers.py          # Вспомогательные функции
│       └── technical_indicators.py # Технические индикаторы
│
├── tests/                      # Тесты
│   ├── unit/
│   └── integration/
│
├── data/                       # Данные
│   ├── raw/                   # Сырые данные
│   ├── processed/             # Обработанные данные
│   ├── models/                # Сохраненные модели
│   └── results/               # Результаты бэктестинга
│
├── notebooks/                  # Jupyter ноутбуки
│   ├── data_analysis.ipynb
│   ├── model_training.ipynb
│   └── strategy_development.ipynb
│
├── logs/                       # Логи
├── requirements.txt            # Зависимости
└── README.md                   # Документация
```
### Ключевые компоненты с кодом:
#### 1. Конфигурация (config/config.yaml)
```yaml
trading:
  symbol: "BTCUSDT"
  timeframe: "15m"
  initial_capital: 1000
  max_position_size: 0.1  # 10% от капитала

risk:
  max_drawdown: 0.2      # 20%
  stop_loss: 0.02        # 2%
  take_profit: 0.04      # 4%
  max_leverage: 3

ml:
  model_type: "ensemble"
  retrain_interval: "1d"
  feature_lookback: 100

bybit:
  testnet: true
  rate_limit: 50
```
#### 2. Основной движок (src/core/trading_engine.py)
```python
class TradingEngine:
    def __init__(self, config, strategy, risk_manager):
        self.config = config
        self.strategy = strategy
        self.risk_manager = risk_manager
        self.position_tracker = PositionTracker()
        self.is_running = False
        
    async def start(self):
        """Запуск торгового движка"""
        self.is_running = True
        logger.info("Trading engine started")
        
        while self.is_running:
            try:
                # Получение текущих данных
                market_data = await self.get_market_data()
                
                # Получение сигнала от стратегии
                signal = await self.strategy.generate_signal(market_data)
                
                # Проверка рисков
                if self.risk_manager.approve_trade(signal, self.position_tracker):
                    # Исполнение ордера
                    await self.execute_trade(signal)
                    
                await asyncio.sleep(1)  # Пауза между итерациями
                
            except Exception as e:
                logger.error(f"Error in trading loop: {e}")
                await asyncio.sleep(5)
    
    async def execute_trade(self, signal):
        """Исполнение торгового сигнала"""
        # Расчет размера позиции с учетом рисков
        position_size = self.risk_manager.calculate_position_size(
            signal, self.position_tracker
        )
        
        # Создание ордера
        order = await self.order_manager.create_order(
            symbol=self.config['symbol'],
            side=signal.side,
            quantity=position_size,
            order_type=signal.order_type
        )
        
        self.position_tracker.update_position(order)
```
#### 3. ML Модель (src/ml/model_manager.py)
``` python
class ModelManager:
    def __init__(self, config):
        self.config = config
        self.model = self.load_model()
        self.scaler = StandardScaler()
        self.feature_columns = []
        
    def prepare_features(self, data):
        """Подготовка фичей для модели"""
        features = pd.DataFrame()
        
        # Ценовые фичи
        features['returns'] = data['close'].pct_change()
        features['volatility'] = data['close'].pct_change().rolling(20).std()
        
        # Технические индикаторы
        features['rsi'] = ta.rsi(data['close'])
        features['macd'] = ta.macd(data['close'])
        features['bb_width'] = (ta.bb_upper(data['close']) - ta.bb_lower(data['close'])) / ta.bb_middle(data['close'])
        
        # Стакан цен
        if 'order_book' in data:
            features['bid_ask_spread'] = data['order_book']['best_ask'] - data['order_book']['best_bid']
            features['order_book_imbalance'] = self.calculate_imbalance(data['order_book'])
        
        self.feature_columns = features.columns.tolist()
        return features.dropna()
    
    def predict(self, current_data):
        """Предсказание на новых данных"""
        features = self.prepare_features(current_data)
        features_scaled = self.scaler.transform(features.tail(1))
        
        prediction = self.model.predict(features_scaled)[0]
        confidence = self.model.predict_proba(features_scaled).max()
        
        return {
            'prediction': prediction,  # 1 - buy, 0 - hold, -1 - sell
            'confidence': confidence,
            'features': features.tail(1).to_dict('records')[0]
        }
```
#### 4. Стратегия с ИИ (src/strategies/ml_strategy.py)
```python
class MLStrategy(BaseStrategy):
    def __init__(self, model_manager, config):
        super().__init__(config)
        self.model_manager = model_manager
        self.min_confidence = config.get('min_confidence', 0.6)
        
    async def generate_signal(self, market_data):
        """Генерация торгового сигнала с использованием ИИ"""
        # Получение предсказания от модели
        prediction = self.model_manager.predict(market_data)
        
        if prediction['confidence'] < self.min_confidence:
            return Signal(signal_type='HOLD', confidence=prediction['confidence'])
        
        # Создание сигнала на основе предсказания
        if prediction['prediction'] == 1:
            return Signal(
                signal_type='BUY',
                confidence=prediction['confidence'],
                price=market_data['close'],
                timestamp=market_data['timestamp']
            )
        elif prediction['prediction'] == -1:
            return Signal(
                signal_type='SELL', 
                confidence=prediction['confidence'],
                price=market_data['close'],
                timestamp=market_data['timestamp']
            )
        else:
            return Signal(signal_type='HOLD', confidence=prediction['confidence'])
```
#### 5. Управление рисками (src/core/risk_manager.py)
```python
class RiskManager:
    def __init__(self, config):
        self.config = config
        self.max_drawdown = config['risk']['max_drawdown']
        self.stop_loss = config['risk']['stop_loss']
        self.take_profit = config['risk']['take_profit']
        
    def approve_trade(self, signal, position_tracker):
        """Одобрение торговой операции"""
        if signal.signal_type == 'HOLD':
            return False
            
        # Проверка максимальной просадки
        if position_tracker.current_drawdown >= self.max_drawdown:
            logger.warning("Max drawdown reached, trading suspended")
            return False
            
        # Проверка количества открытых позиций
        if len(position_tracker.open_positions) >= 5:  # максимум 5 позиций
            return False
            
        return True
    
    def calculate_position_size(self, signal, position_tracker):
        """Расчет размера позиции с учетом рисков"""
        account_balance = position_tracker.account_balance
        risk_per_trade = account_balance * 0.02  # 2% риска на сделку
        
        # Расчет размера на основе волатильности
        volatility = self.calculate_volatility(signal.symbol)
        position_size = risk_per_trade / (volatility * self.stop_loss)
        
        return min(position_size, account_balance * 0.1)  # не более 10% от депозита
```
#### 6. Бэктестинг (src/backtesting/backtest_engine.py)
```python
class BacktestEngine:
    def __init__(self, strategy, initial_capital=10000):
        self.strategy = strategy
        self.initial_capital = initial_capital
        self.results = {}
        
    def run(self, historical_data):
        """Запуск бэктестинга на исторических данных"""
        capital = self.initial_capital
        position = 0
        trades = []
        
        for i, row in historical_data.iterrows():
            # Генерация сигнала
            signal = self.strategy.generate_signal(row)
            
            # Исполнение торговли
            if signal.signal_type == 'BUY' and position == 0:
                position = capital / row['close']
                capital = 0
                trades.append({'type': 'BUY', 'price': row['close'], 'timestamp': row['timestamp']})
                
            elif signal.signal_type == 'SELL' and position > 0:
                capital = position * row['close']
                position = 0
                trades.append({'type': 'SELL', 'price': row['close'], 'timestamp': row['timestamp']})
        
        # Расчет результатов
        final_value = capital if capital > 0 else position * historical_data.iloc[-1]['close']
        total_return = (final_value - self.initial_capital) / self.initial_capital
        
        self.results = {
            'initial_capital': self.initial_capital,
            'final_value': final_value,
            'total_return': total_return,
            'total_trades': len(trades),
            'trades': trades
        }
        
        return self.results
```
#### 7. Главный файл (src/main.py)
```python 
async def main():
    # Загрузка конфигурации
    config = load_config('config/config.yaml')
    
    # Инициализация компонентов
    model_manager = ModelManager(config)
    strategy = MLStrategy(model_manager, config)
    risk_manager = RiskManager(config)
    
    # Создание торгового движка
    trading_engine = TradingEngine(config, strategy, risk_manager)
    
    # Запуск системы
    try:
        await trading_engine.start()
    except KeyboardInterrupt:
        logger.info("Shutting down trading engine...")
        trading_engine.stop()
    except Exception as e:
        logger.error(f"Fatal error: {e}")

if __name__ == "__main__":
    asyncio.run(main())
```
#### Ключевые особенности архитектуры:
1. Модульность - каждый компонент независим
2. Масштабируемость - легко добавлять новые стратегии и модели
3. Тестируемость - каждый модуль можно тестировать отдельно
4. Безопасность - разделение рисков и исполнения
5. Мониторинг - подробное логирование всех операций
#### Эта архитектура позволяет начать с простой стратегии и постепенно усложнять систему, добавляя новые ML-модели и методы анализа.